package personal_projects.lambda;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.function.*;



public abstract class AstNode {
    public int pos;

    protected AstNode(int pos) { this.pos = pos; }

    public static abstract class EvalObject extends AstNode {
        public abstract boolean getBoolValue();
        public EvalObject(int pos) {super(pos);}
    }
    //doesn't get generated by the parser
    public static class Builtin extends EvalObject {
        interface Func {
            EvalObject apply(EvalObject o) throws EvalException;
        }
        Func val;
        String name;

        @Override
        public boolean getBoolValue() { return true; }

        public Builtin(Func val, String name) {
            super(0);
            this.val = val;
            this.name = name;
        }
        public EvalObject call(EvalObject arg) throws EvalException { return val.apply(arg); }

        @Override
        public String toString() {
            return "Function " + name;
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) { return this; }
    }

    public static class Int extends EvalObject {
        public BigInteger val;

        @Override
        public boolean getBoolValue() { return !BigIntHelper.isZero(val); }
        public Int(int pos, String val) { this(pos, new BigInteger(val)); }
        public Int(int pos, BigInteger val) {
            super(pos);
            this.val = val;
        }
        @Override
        public String toString() {
            return val.toString();
        }

        @Override
        String toStringTreeImpl(int level) {
            return "int: "+val+"\n";
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) { return this; }
    }

    public static class Binary extends AstNode {
        public AstNode a, b;
        public BiFunction<BigInteger, BigInteger, BigInteger> fun;
        public String op;

        public Binary(int pos, String op, BiFunction<BigInteger, BigInteger, BigInteger> fun, AstNode a, AstNode b) {
            super(pos);
            this.fun = fun;
            this.a = a;
            this.b = b;
            this.op = op;
        }

        @Override
        public String toString() {
            return "("+a+ " "+op+ " "+ b+")";
        }

        @Override
        String toStringTreeImpl(int level) {
            return "binary: "+printChildren(level, a, b);
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) throws EvalException  {
            return new Binary(pos, op, fun, a.withBoundVariable(param, arg), b.withBoundVariable(param,arg));
        }
    }

    public static class Unary extends AstNode {
        public AstNode a;
        public Function<BigInteger, BigInteger> fun;
        public String op;

        public Unary(int pos, String op, Function<BigInteger, BigInteger> fun, AstNode a) {
            super(pos);
            this.fun = fun;
            this.a = a;
            this.op = op;
        }
        @Override
        public String toString() {
            return "("+op+ " "+ a+")";
        }
        @Override
        String toStringTreeImpl(int level) {
            return "unary: "+printChildren(level, a);
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) throws EvalException  {
            return new Unary(pos, op, fun, a.withBoundVariable(param, arg));
        }
    }

    public static class Variable extends AstNode {
        public String name;
        public Variable(int pos, String name) {
            super(pos);
            this.name = name;
        }
        @Override
        public String toString() { return name; }
        @Override
        String toStringTreeImpl(int level) {
            return "var '"+name+"'\n";
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) {
            return name.equals(param) ? arg : this;
        }
    }
    public static class FunCall extends AstNode {
        public AstNode fun;
        public AstNode arg;
        public FunCall(int pos, AstNode fun, AstNode arg) {
            super(pos);
            this.fun = fun;
            this.arg = arg;
        }
        @Override
        public String toString() { return "("+fun+" "+ arg+")"; }
        @Override
        String toStringTreeImpl(int level) {
            return "funCall: "+printChildren(level,fun, arg);
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) throws EvalException {
            return new FunCall(pos, fun.withBoundVariable(param, arg), this.arg.withBoundVariable(param, arg));
        }
    }
    public static class Lambda extends EvalObject {
        public String param;
        public AstNode body;
        public Lambda(int pos, String param, AstNode body) {
            super(pos);
            this.param = param;
            this.body = body;
        }

        @Override
        public boolean getBoolValue() { return true; }

        public EvalObject call(EvalObject arg, Evaluator eval) throws EvalException {
            return eval.eval(body.withBoundVariable(param, arg));
        }
        @Override
        public String toString() { return "\u03bb"+param+". "+body; }
        @Override
        String toStringTreeImpl(int level) {
            return "lambda "+ param+": "+printChildren(level,body);
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) throws EvalException {
            if (this.param.equals(param)) return this;
            return new Lambda(pos, this.param, body.withBoundVariable(param, arg));
        }
    }
    public static class Assign extends AstNode {
        public String name;
        public AstNode val;
        public Assign(int pos, String name, AstNode val) {
            super(pos);
            this.val = val;
            this.name = name;
        }
        @Override
        public String toString() {
            return name + " = "+ val;
        }
        @Override
        String toStringTreeImpl(int level) {
            return "assign "+name+":"+printChildren(level,val);
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) throws EvalException {
            if (name.equals(param))
                throw new EvalException(pos, "Can't reassign parameter");
            return new Assign(pos, name, val.withBoundVariable(param, arg));
        }
    }

    public static class Or extends AstNode {
        public AstNode a, b;
        public Or(int pos, AstNode a, AstNode b) {
            super(pos);
            this.a = a;
            this.b = b;
        }
        @Override
        public String toString() { return "("+a+" || "+ b+")"; }
        @Override
        String toStringTreeImpl(int level) {
            return "or: "+printChildren(level,a, b);
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) throws EvalException {
            return new Or(pos, a.withBoundVariable(param, arg), b.withBoundVariable(param, arg));
        }
    }
    public static class And extends AstNode {
        public AstNode a, b;
        public And(int pos, AstNode a, AstNode b) {
            super(pos);
            this.a = a;
            this.b = b;
        }
        @Override
        public String toString() { return "("+a+" && "+ b+")"; }

        @Override
        String toStringTreeImpl(int level) {
            return "and: "+printChildren(level,a, b);
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) throws EvalException  {
            return new And(pos, a.withBoundVariable(param, arg), b.withBoundVariable(param, arg));
        }
    }
    public static class If extends AstNode {
        public AstNode cond, t, f;
        public If(int pos, AstNode cond, AstNode t, AstNode f) {
            super(pos);

            this.t = t;
            this.f = f;
            this.cond = cond;
        }
        @Override
        public String toString() { return "("+cond+" ? "+  t + " : " + f+")"; }
        @Override
        String toStringTreeImpl(int level) {
            return "if: "+printChildren(level,cond, t, f);
        }

        @Override
        AstNode withBoundVariable(String param, AstNode arg) throws EvalException  {
            return new If(pos, cond.withBoundVariable(param, arg), t.withBoundVariable(param, arg), f.withBoundVariable(param, arg));
        }
    }

    public String toStringTree() {
        return toStringTree(0);
    }
    String printChildren(int level, AstNode... nodes) {
        StringBuilder res = new StringBuilder("\n");
        for (AstNode n : nodes)
            res.append(n.toStringTree(level + 1));
        return res.toString();
    }
        
    String toStringTreeImpl(int level) { return toString(); }
    
    public String toStringTree(int level) {
        char[] repeat = new char[level*2];
        Arrays.fill(repeat, ' ');
        String indent = new String(repeat);
        if (level != 0) indent += "| ";

        return indent + toStringTreeImpl(level);
    }

    // replacing the variable directly should be fine since
    // we don't carry any state with our `EvalObject`s
    // only downside is that we can't reassign the parameter
    abstract AstNode withBoundVariable(String param, AstNode arg) throws EvalException;
}
